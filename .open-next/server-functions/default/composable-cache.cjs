globalThis.disableIncrementalCache = false;globalThis.disableDynamoDBCache = false;globalThis.isNextAfter15 = true;globalThis.openNextDebug = false;globalThis.openNextVersion = "3.9.12";
var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var b=(e,t)=>{for(var a in t)c(e,a,{get:t[a],enumerable:!0})},x=(e,t,a,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of p(t))!T.call(e,r)&&r!==a&&c(e,r,{get:()=>t[r],enumerable:!(n=m(t,r))||n.enumerable});return e};var v=e=>x(c({},"__esModule",{value:!0}),e);var C={};b(C,{default:()=>w});module.exports=v(C);function i(...e){globalThis.openNextDebug&&console.log(...e)}function N(e){return typeof e=="string"?e:JSON.stringify({tag:e.tag,path:e.path})}async function l(e){let t=globalThis.__openNextAls.getStore();if(i("Writing tags",e,t),!t||globalThis.openNextConfig.dangerous?.disableTagCache)return;let a=e.filter(n=>{let r=N(n),o=!t.writtenTags.has(r);return o&&t.writtenTags.add(r),o});a.length!==0&&await globalThis.tagCache.writeTags(a)}var g=require("node:stream/web");async function d(e,t){let a=[],n=0;for await(let s of e)a.push(s),n+=s.length;if(a.length===0)return"";if(a.length===1)return Buffer.from(a[0]).toString(t?"base64":"utf8");let r=Buffer.alloc(n),o=0;for(let s of a)r.set(s,o),o+=s.length;return r.toString(t?"base64":"utf8")}function f(e,t){return new g.ReadableStream({pull(a){a.enqueue(Buffer.from(e,t?"base64":"utf8")),a.close()}},{highWaterMark:0})}var u=new Map,w={async get(e){try{if(u.has(e)){let a=u.get(e);if(a)return a.then(n=>({...n,value:f(n.value)}))}let t=await globalThis.incrementalCache.get(e,"composable");if(!t?.value?.value)return;if(i("composable cache result",t),globalThis.tagCache.mode==="nextMode"&&t.value.tags.length>0){if(t.shouldBypassTagCache?!1:await globalThis.tagCache.hasBeenRevalidated(t.value.tags,t.lastModified))return}else if((globalThis.tagCache.mode==="original"||globalThis.tagCache.mode===void 0)&&(t.shouldBypassTagCache?!1:await globalThis.tagCache.getLastModified(e,t.lastModified)===-1))return;return{...t.value,value:f(t.value.value)}}catch{i("Cannot read composable cache entry");return}},async set(e,t){let a=t.then(async r=>({...r,value:await d(r.value)}));u.set(e,a);let n=await a.finally(()=>{u.delete(e)});if(await globalThis.incrementalCache.set(e,{...n,value:n.value},"composable"),globalThis.tagCache.mode==="original"){let r=await globalThis.tagCache.getByPath(e),o=n.tags.filter(s=>!r.includes(s));o.length>0&&await l(o.map(s=>({tag:s,path:e})))}},async refreshTags(){},async getExpiration(...e){return globalThis.tagCache.mode==="nextMode"?globalThis.tagCache.getLastRevalidated(e.flat()):0},async expireTags(...e){if(globalThis.tagCache.mode==="nextMode")return l(e);let t=globalThis.tagCache,a=Date.now(),n=await Promise.all(e.map(async o=>(await t.getByTag(o)).map(h=>({path:h,tag:o,revalidatedAt:a})))),r=new Set;for(let o of n.flat())r.add(o);await l(Array.from(r))},async receiveExpiredTags(...e){}};
